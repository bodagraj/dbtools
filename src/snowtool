#!/usr/bin/python3
import multiprocessing as mp
import logging
import threading
import time
from logging.handlers import RotatingFileHandler
import os
import subprocess
import tempfile
import pprint
import json
import sys



#print("Number of processors: ", mp.cpu_count())


def setup_logging():
	
	"""
	Setup a default log file to /tmp/filename.log
	logfile will be rotated if it crosses 500MB upto maximum of 4 recent logs
	Format prints as follows
	2022-01-27 02:16:09,713 - [DEBUG] - [Thread-1] - root - (snowtool.py).worker(12) - Hi from myfunc
	2022-01-27 02:16:09,714 - [DEBUG] - [MainThread] - root - (snowtool.py).main(38) - Hello from main
	"""
	
	prog_name = os.path.basename(os.path.realpath(__file__))
	fname = tempfile.gettempdir() +'/'+ prog_name + '.log'
	logging.basicConfig(
		level=logging.DEBUG,
		format="%(asctime)s - [%(levelname)s] - [%(threadName)s] - %(name)s - (%(filename)s).%(funcName)s(%(lineno)d) - %(message)s",
		handlers=[RotatingFileHandler(filename=fname,mode='w', maxBytes=512000, backupCount=4)]
	)
	print("check detailed progress in [",fname,"] hit cntrl+c to terminate the program")

		
def main():

	"""
	Multi threaded program it uses multithreading rater than multiprocessing, as the logic of this progra is not compute intesnive.
	"""
	
	info = {'stop': False}
	thread = threading.Thread(target=worker, args=(info,))
	thread.start()
	
		
	try:
		logging.debug('Hello from main')
		time.sleep(0.75)
		
	except KeyboardInterrupt:
		info['stop'] = True
		logging.critical("keyboard inturrupt recieved terminating the program...",info)
		
	thread.join()

def worker(arg):
	while not arg['stop']:
		logging.debug('Hi from worker function')
		cmd_args = {
					'cmd' : 'ping1',
					'args' : 'python.org'
					}
		
		status = None
		try:
			status = execute_command(cmd_args)
		except Exception as ex:
			json_string = json.dumps(status)
			logging.critical(ex)
			logging.critical(json_string+"\nThread failure, exiting...")
			sys.exit()
		
		time.sleep(0.5)

def connect_teradata():
	return dbh

def execute_command(arg):

	"""
	Takes command and arguments in a dictionary and returns the status back
	"""
	cmd = arg['cmd']
	args = arg['args']
	#my_arg = pprint.pformat(arg)
	json_string = json.dumps(arg)
	logging.debug("Executing with the following arguments:\n"+json_string)
	
	out = ''
	err = ''
	return_code = -1
	process = None
	
	try:
		process = subprocess.Popen(
			[cmd, args], 
			stdout=subprocess.PIPE,
			universal_newlines=True
		)
	except FileNotFoundError as e:
		#err = "".join(process.stderr.readlines())
		err = 'Command failed, exception returned:'+format(e)+',exiting....'
		logging.critical(err)
		#sys.exit()
	except:
		logging.critical("Error, Exception not handled , exiting...")
		#sys.exit()
	
	if process is not None:
		return_code = process.poll()
	else:
		logging.critical('processing failed, preparing to exit...')
		sys.exit(-1)
		
	
	while True:
		#output = process.stdout.readline()
		#logging.info(output.strip())
		# Do something else, grepping et.c....
		return_code = process.poll()
		
		if return_code is not None:
			logging.info('RETURN CODE:'+ str(return_code))
			# Process has finished, read rest of the output
			out = "".join(process.stdout.readlines())
			logging.info("Command returned\n"+out)
			#for output in out:
			#	logging.info(output.strip())
			
			if return_code != 0:
				logging.critical('Command failed, please check messages above')
			
			break
	
	return {
		'output' : out+"\n"+err,
		'return_code' : return_code
	}

if __name__ == '__main__':
	setup_logging()
	main()
